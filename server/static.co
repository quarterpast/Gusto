# static.co
# methods for serving static files
util = require \util
pathutil = require \path
mime = require \mime
crypto = require \crypto
{Stream} = require \stream
http = require \http
fs= require \fs

cachezlib = require "./cachezlib.co"
list = require "../mvc/list.co"
Renderer = require "../mvc/renderer.co"
ErrorHandler = require "../mvc/error.co"
reverse = require "../mvc/template.co" .route

exports.file = (request,result,path)->
	# serve an individual file
	exists <- pathutil.exists path 
	if exists
		err,stat <- fs.stat path
		if err then
			result.writeHead 501,"could not stat #{path}"
			result.end!

		ext = pathutil.extname path .substr 1
		type = mime.lookup path

		{type} = filter = list.filters.(ext) if ext in list.filters

		read = fs.createReadStream path
		hash = crypto.createHash "sha224"

		baseHead =
			\content-type : type
			\cache-control : "max-age=31556926"
			\expires : Date.create "next year" .format Date.RFC1123
			\trailer :"Etag"

		hash.update request.headers.host

		if "accept-encoding" in request.headers
			# THIS IS NOT RFC 2616 COMPLIANT
			# will probably crash if given qvalues
			[enc] = request.headers.accept-encoding.split ','
			cached = cachezlib enc.capitalize! do
				path+stat.mtime.getTime!,
				stat.size

		Stream::filter = (dest,opts) ->
			if filter?
				b = new Buffer stat.size
				off = 0
				@on "data", (chunk)->
					chunk.copy b,off
					off += chunk.length
				@on "end", ->
					filter b,path .on "error" ->
						result.writeHead 501,"could not filter #{path}"
						result.end!
					.on "data",(out)->
						dest.end out
			else @pipe dest,opts

		read.on "data" (chunk)->
			hash.update chunk

		read.on "end" ->
			result.addTrailers Etag:hash.digest "hex"

		if enc
			result.writeHead 200,baseHead <<< \content-encoding : enc
			read.resume!
			read.filter cached .pipe result

		else
			result.writeHead 200,baseHead
			read.resume!
			read.filter result

	else
		result.writeHead 404,"#{path} not found"
		result.end!

exports.file.id = \static.file

exports.dir = (request,result,dir,vars)->
	exports.file request,result,pathutil.join dir,vars.file

exports.dir.id = \static.dir

exports.template = (request,result,dir,vars)->
	r = new Renderer vars.file,{},null,null,true

	r.on "render" (output)->
		result.writeHead 200,\Content-type :"text/x-template"
		result.end output;

	r.on "error" (e)->
		h = new ErrorHandler e
		output <- h.on "render"
		result.writeHead 501,\Content-type :"text/html"
		result.end output;

exports.template.id = \static.template