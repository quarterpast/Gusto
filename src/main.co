path = require \path
cluster = require \cluster
os = require \os
fs = require \fs
util = require \util
Sync = require \sync

exports.async = -> it.async!

exports.Config = new
	@appDir = process.cwd!
	@routes = path.join @appDir,"conf","routes.conf"
	@controllerPath = path.join @appDir,"app","controllers"
	@logLevel = 1
	@port = 8001
	@host = null
	@fork = true

exports.loadConfig = (conf)->
	if typeof conf is \string
		err,json <- fs.readFile conf
		throw err if err
		exports.Config <<< JSON.parse json
	else exports.Config <<< conf

if cluster.isMaster and exports.Config.fork
	exports.run = ->
		cluster.fork! for p of os.cpus!
else 
	exports.run = ->
		class Logger
			@levels = []
			@setLevel = (level)->
				for lvl,i of @levels
					log.silent = i<level for log of lvl

			silent: false
			(@level,@id,@stream=process.stdout)~>
				if ..levels[level]?
					..levels[level].push this
				else
					..levels[level] = [this]
			print: ->
				unless @silent
					@stream.write "#{@id}\t#{process.pid}\t#{util.format ...}\n"

		exports.Log =
			debug: Logger 0,\DEBUG .~print
			log: Logger 1,\LOG .~print
			warn: Logger 2,\WARN,process.stderr .~print
			error: Logger 3,\ERROR,process.stderr .~print

		exports.Config.engines =
			eco: new ->
		
		Logger.setLevel exports.Config.logLevel

		{Server} = require "./server/server"

		exports.Server = new Server exports.Config.port,exports.Config.host