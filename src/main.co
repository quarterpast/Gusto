path = require \path
cluster = require \cluster
os = require \os
fs = require \fs
util = require \util
Sync = require \sync

exports.async = -> it.async!
exports.future = -> it.future!

exports.Config = new
	@appDir = process.cwd!
	@routes = path.join @appDir,"conf","routes.conf"
	@controllerPath = path.join @appDir,"app","controllers"
	@templatePath = path.join @appDir,"app","views"
	@logLevel = 1
	@port = 8001
	@host = null
	@fork = true
		
exports.loadConfig = (conf)->
	if typeof conf is \string
		err,json <- fs.readFile conf
		throw err if err
		exports.Config <<< JSON.parse json
	else exports.Config <<< conf

if cluster.isMaster and exports.Config.fork
	exports.run = ->
		cluster.fork! for p of os.cpus!
else 
	exports.run = ->
		class Logger
			@colours =
				red: "\x1b[31m"
				reset: "\x1b[0m"
			@levels = []
			@setLevel = (level)->
				for lvl,i of @levels
					log.silent = i<level for log of lvl

			silent: false
			(@level,@id,@stream=process.stdout)~>
				if ..levels[level]?
					..levels[level].push this
				else
					..levels[level] = [this]
			print: ->
				unless @silent
					@stream.write "#{@id}\t#{process.pid}\t#{util.format ...}\n"

		vm = require \vm

		exports.Log =
			debug: Logger 0,\DEBUG .~print
			log: Logger 1,\LOG .~print
			warn: Logger 2,\WARN,process.stderr .~print
			error: Logger 3,"#{Logger.colours.red}ERROR#{Logger.colours.reset}",process.stderr .~print

		exports.Config.engines =
			eco:
				compile: exports.async (file)->
					vm.createScript Coco.compile '"""'+(fs.readFile.sync null, file)+'"""',{+bare}
			js:
				compile: exports.async (file)->
					vm.createScript fs.readFile.sync null, file
		
		Logger.setLevel exports.Config.logLevel

		{Server} = require "./server/server"

		exports.Server = new Server exports.Config.port,exports.Config.host

Function::curry = (curried)->
	func = this
	-> func.apply @, [curried]+@@
