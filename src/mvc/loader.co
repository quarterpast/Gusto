fs = require \fs
path = require \path
Sync = require \sync
{signal} = require "./signal"
{Log,async} = require "../main"


class Reloader
	reload: signal!
	(@file)~>
		@watch file, (ev,name=file)~>
			name = with path
				@join @dirname(file), @basename(name)
			@load name,@reload.~fire
	watch: (file,cb)->
		try
			fs.watch file,cb
		catch
			Log.debug "Can't use fs.watch for some reason.\n\tFalling back on fs.watchFile for #{path.basename file}"
			curr,prev <- fs.watchFile file
			if curr.mtime is not prev.mtime
				cb "change",file
	load: async (name = @file)->
		delete require.cache[path.resolve __dirname,name]
		return require name

class exports.Loader
	# recursively merge two objects
	# e.g. merge({a:{b:1}},{a:{c:2}}) -> {a:{b:1,c:2}}
	function merge (dest,src,cb,acc="")
		for k,v in src
			d = if acc.length then "#acc.#k" else k
			if (typeof[dest[k],v]).every(->it is "object")
				merge dest[k],v,cb,d
			else
				dest[k] = if cb? then cb v,d else v
		return dest
	load: signal!
	out: {}
	(@cb)->
	run: async (dir)->
		files = fs.readdir.sync null, dir
		for file of files
			res = path.join dir,file
			stat = fs.stat.sync null, res
			merge @out,if stat.isDirectory!
				l = new Loader @cb
				l.load.connect ~> @load ...
				l.run res
			else
				rl = Reloader res
				rl.reload.connect (e,mod)~>
					@load.fire @out
					merge this,mod
				@load.fire @out
				rl.load!
			, @cb
		return @out