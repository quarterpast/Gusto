fs = require \fs
path = require \path
Sync = require \sync
{signal} = require "./signal"
{Log,async} = require "../main"


class Reloader extends process.EventEmitter
	function watch file,cb
		try
			fs.watch file,cb
		catch
			Log.debug "Can't use fs.watch for some reason.\n\tFalling back on fs.watchFile for #{path.basename file}"
			curr,prev <- fs.watchFile file
			if curr.mtime is not prev.mtime
				cb "change",file
	(@file)~>
		watch file, (ev,name=file)~>
			name = with path
				@join @dirname(file), @basename(name)
			@load name,~> @fire \reload,it
	load: async (name = @file)->
		delete require.cache[path.resolve __dirname,name]
		return require name

exports.Loader = async (dir,merge = (obj,add,fname)->
	for route,action in add.routes
		key = action.id or path.join cont,route
		obj[key] = action
)->
	out = {}
	walk = async (file)->
		stat = fs.stat.sync file
		if stat.isDirectory!
			files = fs.readdir.sync file
			walk path.join file,f for f of files
		else
			rl = Reloader file
			rl.on \reload, (e,mod)->
				merge obj,mod,file
			rl.load!
	walk dir
	return out