fs = require \fs
path = require \path
Sync = require \sync
{async} = require "../magic"
{Log} = require "../log"

exports.Paths = (obj)->
	acc = {}
	function inner o,dir = ''
		for own k,v in o
			p = path.join dir,k
			if v instanceof Function
				acc[p] = v
			else
				inner v,p,acc
	inner obj
	return acc

exports.asPaths = (klass)-> async (obj,file)->
	rl = new klass file
	rl.on \reload, (e,mod)->
		for route,action in exports.Paths mod
			key = action.id or route
			obj[key] = action
	rl.load!

class exports.Reloader extends process.EventEmitter	
	function watch file,cb
		try
			fs.watch file,cb
		catch
			Log.debug "Can't use fs.watch for some reason.\n\tFalling back on fs.watchFile for #{path.basename file}"
			curr,prev <- fs.watchFile file
			if curr.mtime is not prev.mtime
				cb "change",file
	(@file)~>
		watch file, (ev,name=file)~>
			name = with path
				@join @dirname(file), @basename(name)
			@load name,~> @fire \reload,it
	load: async (name = @file)->
		console.log name
		delete require.cache[path.resolve __dirname,name]
		return require name

exports.Loader = async (dir,load = exports.asPaths Reloader)->
	out = {}
	walk = (file)->
		stat = fs.statSync file
		if stat.isDirectory!
			files = fs.readdirSync file
			console.log load
			for f of files
				walk path.join file,f 
		else
			load out,file
	walk dir
	return out