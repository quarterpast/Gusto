# router.co
{Config} = require "../main"
{signal} = require "../mvc/signal"
url = require \url

methods = <[ * HEAD GET POST PUT TRACE DELETE OPTIONS PATCH ]>

class exports.NotFound extends Error
	-> super "Could not route #it"

class exports.Route
	(@method,@path,@action)->
		action.toString = action.route = @~reverse
	match: (request)->
		if @method not of ['*',request.method] then return false
		reqparts = request.path.substr 1 .split '/'
		searchparts = @path.split '/'

		params = {}
		for part,i of searchparts
			reqpart = reqparts.shift!
			if part.0 is '#'
				params[part.substr 1] = reqpart
			else
				if reqpart is not part then return false
		if @action.expects?
			for own param,type in @action.expects
				val = request.post[param]
				or    request.get[param]
				or    params[param]
				or    reqparts.shift!
				params[param] = new type val
		else params <<< request.get <<< request.post
		return params

	reverse: (params)->
		...

class exports.Router
	@routers = []
	@route = (req)->
		for router of @routers
			for route of router.routes
				if params = route.match req then {route.action,params}
				else new exports.NotFound req.url
	routeHash: {}
	routes:~ -> v for k,v in @routeHash
	-> ..routers.push @
	add: (method or '*',path,action)->
		@routeHash["#method #path"] = if method instanceof Route 
			method
		else new Route method,path,action

	for m of methods
		::[m] = ::add.bind null,m.toUpperCase!

	use: (obj)->
		if obj.reload? then obj.reload.connect (keys)~>
			for key of keys
				@add obj[key].method, key, obj[key]

		for own path, func in obj
			@add func.method, path, func

for m of methods
	exports[m] = (id,func)->
		[id,func] = [[],id] if (typeof id) is \function
		id = [id] if (typeof id) is \string
		if func.id?
			id .= concat func.id
		func <<< {
			id
			method: m.toUpperCase!
		}