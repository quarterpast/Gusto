# router.co
{Config} = require "../main"
{signal} = require "../mvc/signal"
url = require \url

methods = <[ * HEAD GET POST PUT TRACE DELETE OPTIONS PATCH ]>

class exports.NotFound extends Error
	-> super "Could not route #it"

class exports.Route
	(@method or '*',@path,@action)->
		action.toString = action.route = @~reverse
	match: (request)->
		if @method not of ['*',request.method] then return false
		reqparts = request.path.substr 1 .split '/'
		searchparts = @path.split '/'

		params = {}
		for part,i of searchparts
			reqpart = reqparts.shift!
			if part.0 is '#'
				params[part.substr 1] = reqpart
			else
				if reqpart is not part then return false
		if @action.expects?
			for own param,type in @action.expects
				val = request.post[param]
				or    request.get[param]
				or    params[param]
				or    reqparts.shift!
				params[param] = type val
		else params <<< request.get <<< request.post
		return params

	reverse: (params)->
		...

class exports.Router
	@routers = []
	@route = (req)->
		for router of @routers
			for route of router.routes
				if params = route.match req then {route.action,params}
				else new NotFound req.url

	routes: []
	-> ..routers.push @
	add: (method,path,action)->
		@routes.push if method instanceof Route then method
		else new Route method,path,action

	for m of methods
		::[m] = ::add.bind null,m.toUpperCase!

	use: (obj)->
		if obj.reload? then obj.reload.connect (keys)~>
			for key of keys
				@add obj[key].method, key, obj[key]

		for own path, func in obj
			@add func.method, path, func

for m of methods
	exports[m] = -> it <<< {method:m.toUpperCase!}