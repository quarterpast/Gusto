# router.co
{Config} = require "../main"
{signal} = require "../mvc/signal"
url = require \url

methods = <[ * HEAD GET POST PUT TRACE DELETE OPTIONS PATCH ]>

class exports.NotFound extends Error
	-> super "Could not route #it"

class exports.Route
	(@method or '*',@path,@action)->
		action.toString = action.route = @~reverse
	match: (request)->
		if @method not of ['*',request.method] then return false
		searchparts = request.path.split '/'
		reqparts = @path.substr 1 .split '/'
		for part,i of reqparts
			reg = if part.0 is '#'
				/(%[0-9a-f]{2}|[a-z0-9-_.!~'():@&=+,$]*)(;(%[0-9a-f]{2}|[a-z0-9-_.!~'():@&=+,$])*)*/ #RFC 2396
			else //#part//
			console.log part,searchparts.0
			if reg.test searchparts.shift! then return false

	reverse: (params)->
		...

class exports.Router
	@routers = []
	@route = (req)->
		for router of @routers
			for route of router.routes
				if params = route.match req then {route.action,params}
				else new NotFound req.url

	routes: []
	-> ..routers.push @
	add: (method,path,action)->
		@routes.push if method instanceof Route then method
		else new Route method,path,action

	for m of methods
		::[m] = ::add.bind null,m.toUpperCase!

	use: (obj)->
		if obj.reload? then obj.reload.connect (keys)~>
			for key of keys
				@add obj[key].method, key, obj[key]

		for own path, func in obj
			@add func.method, path, func

for m of methods
	exports[m] = -> it <<< {method:m.toUpperCase!}