# router.co
{Config} = require "../main"
{signal} = require "../mvc/signal"
url = require \url

methods = <[ * HEAD GET POST PUT TRACE DELETE OPTIONS PATCH ]>

class exports.NotFound extends Error
	-> super "Could not route #it"

class exports.Route
	(@method,@path,@action)->
		action.toString = action.route = @~reverse
	match: (request)->
		if @method not of ['*',request.method] then return false
		reqparts = request.path.substr 1 .split '/'
		searchparts = @path.split '/'

		params = {}
		for part,i of searchparts
			reqpart = reqparts.shift!
			if part.0 is '#'
				params[part.substr 1] = reqpart
			else
				if reqpart is not part then return false
		if @action.expects?
			for own param,type in @action.expects
				val = request.post[param]
				or    request.get[param]
				or    params[param]
				or    reqparts.shift!
				params[param] = new type val
		else params <<< request.get <<< request.post
		return params

	reverse: (params)->
		...

class exports.Router
	@routers = []
	@route = (req)->
		for router of @routers
			for route of router.routes
				if params = route.match req then {route.action,params}
				else new exports.NotFound req.url
	routeHash: {}
	routes:~ -> v for k,v in @routeHash
	-> ..routers.push @
	add: (method or '*',path,action)->
		@routeHash["#method #path"] = if method instanceof Route 
			method
		else new Route method,path,action

	for m of methods
		::[m] = ::add.bind null,m.toUpperCase!

	use: (obj,re=true)->
		if re and obj.reload?
			obj.reload.connect (keys)~> @use obj,false

		for own path, func in obj
			if action.aliases?
				for p,method in action.aliases
					@add method, p, func
			@add func.method, path, func

exports.alias = (obj,func)->
	func.aliases <<< obj
	return func

methods.forEach (method)->
	exports[method.toLowerCase!] = (id,func)->
		if typeof id is \string
			exports.alias (id):method, func
		else
			func <<< {method}